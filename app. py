 import os
from fastapi import FastAPI, HTTPException
 from fastapi.concurrency import asynccontextmanager
 from pydantic import BaseModel
 from detect_ai_model import detect_health_claim, get_detector
 from translator import translate_terms
 from verify_api_infermedica import verify_with_infermedica_async


 # Configuration: use env vars if set, otherwise fallback to provided demo keys
 APP_ID = os.environ.get("INFERMEDICA_APP_ID", "88633e4d")
 APP_KEY = os.environ.get("INFERMEDICA_APP_KEY", "3d686bb5adb4769123514f44b41a9fda")


 class MessageInput(BaseModel):
 	message: str


 @asynccontextmanager
 async def lifespan(app: FastAPI):
 	# Background warmup so the server starts fast and model loads concurrently
 	def _warmup():
 		try:
 			print("‚öôÔ∏è Warming up model in background...")
 			get_detector()
 			print("‚úÖ Model warmed up")
 		except Exception as e:
 			# If warmup fails, we still let the app run but log the error
print("‚ö†Ô∏è Model warmup failed:", e)

 	import threading
 	threading.Thread(target=_warmup, daemon=True).start()
 	yield
 	print("üîª Server shutting down")


 app = FastAPI(title="MediCorrect Backend", lifespan=lifespan)


 @app.get("/")
 async def home():
	return {"message": "Welcome to MediCorrect"}


 @app.post("/analyze/")
 async def analyze_message(payload: MessageInput):
 	message = payload.message

 	# 1) Translate colloquial/Indian terms to clinical terms
 	clean_text = translate_terms(message)

 	# 2) AI model label (lazy loads model if necessary)
 	try:
 		ai_label = detect_health_claim(clean_text)
 	except Exception as e:
 		# If model isn't available, return an error
 		raise HTTPException(status_code=500, detail=str(e))

 	# 3) Verify using Infermedica async API call
 	try:
 		api_response = await verify_with_infermedica_async(clean_text, APP_ID, APP_KEY)
 	except Exception as e:
 		# Nonfatal: include error text but keep API responsive
 		api_response = {"error": str(e)}

 	return {
 		"user_input": message,
		"translated_text": clean_text,
 		"ai_label": ai_label,
 		"verified_api_result": api_response
 	}

 async def analyze_message(req: MessageInput):

     message = req.message
     clean_text = translate_terms(message)
     ai_label = detect_health_claim(clean_text)
     api_response = await verify_with_infermedica_async(clean_text, APP_ID, APP_KEY)

     return 
         "user_input": message,
         "translated_text": clean_text,
         "ai_label": ai_label,
         "verified_api_result": api_response
    }
